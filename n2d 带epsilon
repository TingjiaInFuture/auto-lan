def nfa_to_epsilon_free_nfa(nfa):
    # 创建一个新的ε自由NFA
    epsilon_free_nfa = {}

    # 对于每个状态，找出所有可能的转换状态
    for current_state, transitions in nfa.items():
        # 初始化新NFA中的状态转换字典
        if current_state not in epsilon_free_nfa:
            epsilon_free_nfa[current_state] = {}
        # 处理当前状态的所有符号转换
        for symbol, target_states in transitions.items():
            if symbol != 'epsilon':
                # 计算目标状态集的ε闭包
                epsilon_closure = get_epsilon_closure(nfa, target_states)
                # 将计算得到的ε闭包作为新NFA中当前状态对应符号的转换目标
                epsilon_free_nfa[current_state][symbol] = epsilon_closure

    return epsilon_free_nfa

# 辅助函数，用于获取通过ε转换可到达的所有状态
def get_epsilon_closure(nfa, states, visited=None):
    if visited is None:
        visited = set()
    closure = set(states)
    for state in states:
        if state in closure and state not in visited:  # 确保只处理尚未访问的、在闭包内的状态
            visited.add(state)
            if 'epsilon' in nfa[state]:
                closure |= get_epsilon_closure(nfa, nfa[state]['epsilon'], visited)
    return closure

def epsilon_free_nfa_to_dfa(epsilon_free_nfa):
    # 获取NFA的初始状态
    initial_state = get_epsilon_closure(epsilon_free_nfa, {0})
    print("Initial state:", initial_state)
    dfa = {str(initial_state): {}}
    unmarked = [initial_state]

    while unmarked:
        T = unmarked.pop()
        print("Current state in DFA:", T)
        if str(T) not in epsilon_free_nfa:
            print("Warning: State", T, "not found in epsilon_free_nfa. Skipping...")
            continue
        for _input in epsilon_free_nfa[str(T)].keys():
            print("Processing input:", _input)
            U = set()
            for state in T:
                if state in epsilon_free_nfa and _input in epsilon_free_nfa[state]:
                    U = U.union(epsilon_free_nfa[state][_input])
            U = frozenset(U)
            print("Next state:", U)
            if str(U) not in dfa.keys() and U:
                dfa[str(U)] = {}
                unmarked.append(U)
            if U:
                dfa[str(T)][_input] = str(U)
        print("DFA after processing inputs:", dfa)

    return dfa


def tuple_to_dict(nfa_tuple):
    Q, Σ, δ, q0, F = nfa_tuple
    nfa_dict = {}
    for state in Q:
        nfa_dict[state] = {}
        for symbol in Σ:
            if (state, symbol) in δ:
                nfa_dict[state][symbol] = δ[state, symbol]
    return nfa_dict

def dict_to_tuple(dfa_dict):
    Q = set(key for key in dfa_dict.keys())  # 直接使用集合，而不是尝试eval转换
    Σ = set(next(iter(dfa_dict.values())).keys())
    δ = {}
    for state, transitions in dfa_dict.items():
        for symbol, next_state in transitions.items():
            δ[state, symbol] = next_state  # 这里不需要将集合转换为字符串，因为它们已经是集合类型
    q0 = next(iter(Q))
    F = {state for state in Q if any(next_state in Q for next_state in dfa_dict[state].values())}
    return Q, Σ, δ, q0, F

def main():
    # 从命令行接收五元组
    Q = set(eval(input("请输入状态集Q(例如:{0, 1, 2}):")))
    Σ = set(eval(input("请输入字母表Σ,ε 转换为'epsilon'(例如:{'a', 'b'}):")))
    δ = eval(input("请输入转移函数δ(例如:{(0, 'a'): {0, 1}, (0, 'b'): {0}, (1, 'a'): {2}, (1, 'b'): {2}, (2, 'a'): {2}, (2, 'b'): {2}}):"))
    q0 = int(input("请输入初始状态q0(例如:0):"))
    F = set(eval(input("请输入接受状态集F(例如:{2}):")))

    # 将五元组转换为字典形式的NFA
    nfa = tuple_to_dict((Q, Σ, δ, q0, F))
    print("NFA:")
    print(nfa)
    # 将nfa转化为不带epsilon的nfa
    epsilon_free_nfa = nfa_to_epsilon_free_nfa(nfa)
    print("epsilonless_nfa:")
    print(epsilon_free_nfa)
    # 将NFA转换为DFA
    dfa = epsilon_free_nfa_to_dfa(epsilon_free_nfa)
    print("DFA:")
    print(dfa)

    # 将字典形式的DFA转换回五元组形式
    dfa_tuple = dict_to_tuple(dfa)
    print("DFA(五元组形式）:")
    print(dfa_tuple)

if __name__ == "__main__":
    main()
